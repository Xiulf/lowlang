package test

extern malloc: fn "c"(usize) -> (&unit);

export fn main "ll"(_0: i32, _1: &&u8) -> (_2: i32) {
    _3: &(i32, bool)

    %0 {
        call _3 = new<T=(i32, bool)>(cons), %1
    }

    %1 {
        _2 = (*_3).0
        return
    }
}

fn new "ll"<type T>(_0: fn "ll"(&T) -> ()) -> (_1: &T) {
    _2: usize
    _3: &unit

    %0 {
        _2 = sizeof T
        call _3 = malloc(_2), %1
    }

    %1 {
        _1 = cast &T, _3
        call _0(_1), %2
    }

    %2 {
        return
    }
}

fn cons "ll"(_0: &(i32, bool)) -> () {
    %0 {
        (*_0).0 = 47i32
        (*_0).1 = 1 bool
        return
    }
}

@lang
fn __insintric_gcd "ll"(_0: isize, _1: isize) -> (_2: isize) {
    _3: bool
    _4: isize

    %0 {
        _3 = eq _1 0isize
        switch _3 [0: %2, otherwise %1]
    }

    %1 {
        _2 = _0
        return
    }

    %2 {
        _4 = rem _0 _1
        call _2 = __insintric_gcd(_1, _4), %3
    }

    %3 {
        return
    }
}

@lang
fn __insintric_lcm "ll"(_0: isize, _1: isize) -> (_2: isize) {
    _3: isize
    _4: isize

    %0 {
        _3 = mul _0 _1
        call _4 = __insintric_gcd(_0, _1), %1
    }

    %1 {
        _2 = div _3 _4
        return
    }
}

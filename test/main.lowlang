package test

extern fn malloc "c"(usize) -> (&unit)
extern fn realloc "c"(&unit, usize, usize) -> (&unit)

// type Vec<T> = (RawVec<T=T>, usize)
// type RawVec<T> = (&T, usize)

export fn main "ll"(_0: i32, _1: &&u8) -> (_2: i32) {
    _3: ((&i32, usize), usize)
    _4: &((&i32, usize), usize)

    %0 {
        call _3 = Vec_new<T=i32>(), %1
    }

    %1 {
        _4 = &_3
        call Vec_push<T=i32>(_4, 27i32), %2
    }

    %2 {
        _2 = *_3.0.0
        return
    }
}

@inline
fn Vec_new "ll"<type T>() -> (_0: ((&T, usize), usize)) {
    _1: (&T, usize)

    %0 {
        call _1 = RawVec_new<T=T>(), %1
    }

    %1 {
        _0.0 = _1
        _0.1 = 0usize
        return
    }
}

fn Vec_push "ll"<type T>(_0: &((&T, usize), usize), _1: T) -> () {
    _2: &(&T, usize)
    _3: usize
    _4: &T

    %0 {
        _2 = &(*_0).0
        call RawVec_reserve<T=T>(_2, (*_0).1, 1usize), %1
    }

    %1 {
        _3 = cast usize, (*_0).0.0
        _3 = add _3 (*_0).1
        _4 = cast &T, _3
        *_4 = _1
        return
    }
}

fn RawVec_new "ll"<type T>() -> (_0: (&T, usize)) {
    _1: usize
    _2: usize

    %0 {
        _1 = sizeof T
        _2 = alignof T
        _0.0 = cast &T, _2
        switch _1 [0: %1, otherwise %2]
    }

    %1 {
        _0.1 = 18446744073709551615usize
        return
    }

    %2 {
        _0.1 = 0usize
        return
    }
}

fn RawVec_reserve "ll"<type T>(_0: &(&T, usize), _1: usize, _2: usize) -> () {
    _3: usize
    _4: bool
    _5: usize
    _6: &unit
    _7: usize

    %0 {
        _3 = sub (*_0).1 _1
        _4 = ge _3 _2
        switch _4 [0: %2, otherwise %1]
    }

    %1 {
        return
    }

    %2 {
        _3 = add _1 _2
        _5 = sizeof T
        _3 = mul _3 _5
        _5 = alignof T
        _7 = cast usize, (*_0).0
        _4 = eq _7 _5
        switch _4 [0: %3, otherwise %4]
    }

    %3 {
        _6 = cast &unit, (*_0).0
        _5 = sizeof T
        _7 = mul (*_0).1 _5
        call _6 = realloc(_6, _7, _3), %5
    }

    %4 {
        call _6 = malloc(_3), %5
    }

    %5 {
        (*_0).0 = cast &T, _6
        return
    }
}

@lang
fn __insintric_gcd "ll"(_0: isize, _1: isize) -> (_2: isize) {
    _3: bool
    _4: isize

    %0 {
        _3 = eq _1 0isize
        switch _3 [0: %2, otherwise %1]
    }

    %1 {
        _2 = _0
        return
    }

    %2 {
        _4 = rem _0 _1
        call _2 = __insintric_gcd(_1, _4), %3
    }

    %3 {
        return
    }
}

@lang
fn __insintric_lcm "ll"(_0: isize, _1: isize) -> (_2: isize) {
    _3: isize
    _4: isize

    %0 {
        _3 = mul _0 _1
        call _4 = __insintric_gcd(_0, _1), %1
    }

    %1 {
        _2 = div _3 _4
        return
    }
}
